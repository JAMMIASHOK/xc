%File: ~/OOP/matrix/ID.tex
%What: "@(#) ID.tex, revA"

\noindent {\bf Files}
\indent \#include \f$<\tilde{ }\f$/matrix/ID.h\f$>\f$

\noindent {\bf Class Declaration}
\indent class ID:

\noindent {\bf Class Hierarchy}
\indent {\bf ID}

\noindent {\bf Description}
\indent The ID class provides the abstraction for an integer Vector. 
//! The class is introduced in addition to the Vector class, to save memory
//! and casting when integer arrays are required. An ID of order {\em
//! size} is an ordered 1d array of \p size integer values. For example
//! an ID id of order 5:

\indent\indent \f$id = [id_0\f$ \f$id_1\f$ \f$id_2\f$ \f$id_3\f$ \f$id_4]\f$

//! In the ID class, the data is stored in a 1d integer array of length
//! equal to arraySize, where order <= arraySize. Creating an ID with
//! storage capacity greater than that required allows the ID object to
//! grow without the need to deallocate and allocate more memory. At
//! present time none of the methods are declared as being virtual. THIS
//! MAY CHANGE.

\noindent {\bf Class Interface}
\indent {// Constructors} 
\indent {\em ID();}
\indent {\em  ID(int idSize);}
\indent {\em  ID(int idSize, int arraySize);}
\indent {\em  ID(const ID \&M); }
\indent {// Destructor}
\indent {\em virtual~ \f$\tilde{}\f$ID();}
\indent {// Public Methods }
\indent {\em virtual int Size() const;}
\indent {\em virtual void Zero();}
\indent {\em virtual int getLocation(int x) const;}
\indent {\em virtual int removeValue(int x);}
\indent {// Overloaded Operator Functions}
\indent {\em virtual double \&operator()(int x);}
\indent {\em virtual double \&operator[](int x);}
\indent {\em virtual ID \&operator=(const ID \&M);}
\indent {\em friend OPS_Stream \&operator\f$<<\f$(OPS_Stream \&s, const ID
\&id);}  
\indent {\em friend istream \&operator\f$<<\f$(istream \&s, const ID
\&id);} 



\noindent {\bf Constructors}
\indent {\em ID();}
//! To construct an ID of size \f$0\f$. No memory is allocated for the storage
//! of the data.

\indent {\em  ID(int idSize);}

\indent {\em  ID(int idSize, int arraySize);}
//! To construct a ID of size \p idSize. The constructor creates an
//! integer array of size \p arraySize to store the data and zeroes
//! this array. If \p arraySize is less than \p idSize, the new {\em
//! arraySize} is set equal to \p idSize. If not enough memory is
//! available an error message is printed and the program is
//! terminated. This constructor is provided to allow an ID to grow.  



\noindent {\bf Public Member Functions }
\indent {\em virtual int Size() const;}
//! Returns the order of the ID.


\noindent {\bf Overloaded Operator Functions}
\indent {\em virtual virtual double \&operator()(int x) const;}
//! Returns the data at location \p x in the ID. Assumes (\p x)
//! is a valid location in the ID, a segmentation fault or erroneous
//! results can occur if this is not the case.

\indent {\em virtual double \&operator()(int x);}
//! Used to set the data at location(\p x) in the ID. Assumes (\p x)
//! is a valid location in the ID, a segmentation fault or erroneous
//! results can occur if this is not the case.

\indent {\em virtual double \&operator[](int x);}
//! Used to set the data at location(\p x) in the ID. If \p x is outside
//! the order of the ID the ID is order of the ID is enlarged to {\em
//! x+1}. When increasing the order, a check is first made to see if the
//! current array is large enough; if it is the components between the old
//! end and the new component are set to \f$0\f$ and the order of the ID is set
//! to {\em x+1}, if not a new array is created. The size of this array is
//! max(\f$2*\f$old array size, x). A copy of the components of the old array
//! into the new array is made, with any new components set to \f$0\f$. If not
//! enough space is available or \p x is less than \f$0\f$, a warning
//! message is printed and the contents of ID\_ERROR returned.


