%File: ~/OOP/matrix/Matrix.tex
%What: "@(#) Matrix.tex, revA"

\noindent {\bf Files}
\indent \#include \f$<\tilde{}\f$/matrix/Matrix.h\f$>\f$

\noindent {\bf Class Declaration}
\indent class Matrix:

\noindent {\bf Class Hierarchy}
\indent {\bf Matrix}

\noindent {\bf Description}
\indent The Matrix class provides the matrix abstraction. A matrix of
//! order numRows X numCols is an ordered 2d array of numbers arranged in
//! numRows rows and numCols columns. For example, a matrix \f$A\f$ of order 2
//! X 3:
\f$\f$ A =
\left[
\begin{array}{ccc}
//! a_{0,0} & a_{0,1}  & a_{0,2}
//! a_{1,0} & a_{1,1} & a_{1,2}
\end{array}
\right] 
\f$\f$

//! The Matrix class provides the implementation of a general unsymmetric
//! matrix. The data for the matrix is stored in a 1d double array of size
//! numRows*numCols with the data for \f$a_{i,j}\f$ located at j*numRows + i
//! in the 1d array. This is similar to the ordering of a Fortran 2d array
//! and will permit calls to numerical Fortran libraries, e.g. BLAS, for
//! certain method calls at a future stage. At present no subclassing is
//! permitted (THIS MAY CHANGE), the reason for this is that the Matrix
//! objects are envisioned to be small scale matrices primarily used for
//! the passing of data between objects in the system. To allow subclassing
//! could reduce the efficiency of the program due to the manner in which 
//! virtual functions are implemented. 



\noindent {\bf Constructors}
\indent {\em Matrix();}
//! To construct a Matrix with numRows = \f$0\f$, and numCols = \f$0\f$. No memory
//! is allocated to store the data. 

\indent {\em  Matrix(int nrows, int ncols);}

\indent {\em  Matrix(double *data, int nrows, int ncols);}



\noindent {\bf Public Methods }
\indent {\em  inline int noRows() const;}
//! Returns the number of rows, numRows, of the Matrix. The method is
//! declared inline for the compiler to produce faster code which does not
//! require a method call.

\indent {\em  inline int noCols() const;}
//! Returns the number of columns, numCols, of the Matrix.




\noindent {\bf Overloaded Operator Functions}
\indent {\em  inline double \&operator()(int row, int col) const;}
//! Returns the data at location({\em row,col}) in the Matrix. Assumes
({\em row,col}) is a valid location in the Matrix, a segmentation
//! fault or erroneous results can occur if this is not the case.

\indent {\em  inline double \&operator()(int row, int col);}
//! Used to set the data at location({\em row,col}) in the Matrix. Assumes
({\em row,col}) is a valid location in the Matrix, a segmentation
//! fault or erroneous results can occur if this is not the case.

\indent {\em  Matrix operator()(const ID \&rows, const ID \&
//! cols) const;} 

\indent {\em  Matrix \&operator=(const Matrix \&M);}
//! Sets the current Matrix to be equal to the Matrix given by \p M. If
//! the Matrices are of different sizes, the current data is deallocated
//! and additional space allocated before the contents are copied. If not
//! enough space can be allocated for the new data, an error message is
//! printed and a Matrix of size \f$0\f$ x \f$0\f$ is returned. The method tests
//! for the type of \p M, to see whether the performance can be
//! improved by avoiding having to call \f$M\f$'s overloaded (i,j) operators,
//! if \f$M\f$ is of type genMatrix. This method must be implemented by each
//! subclass. 

