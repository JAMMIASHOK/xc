%File: ~/OOP/matrix/Matrix.tex
%What: "@(#) Matrix.tex, revA"

\noindent {\bf Files}
\indent \#include \f$<\tilde{}\f$/matrix/Matrix.h\f$>\f$

\noindent {\bf Class Declaration}
\indent class Matrix:

\noindent {\bf Class Hierarchy}
\indent {\bf Matrix}

\noindent {\bf Description}
\indent The Matrix class provides the matrix abstraction. A matrix of
//! order numRows X numCols is an ordered 2d array of numbers arranged in
//! numRows rows and numCols columns. For example, a matrix \f$A\f$ of order 2
//! X 3:
\f$\f$ A =
\left[
\begin{array}{ccc}
//! a_{0,0} & a_{0,1}  & a_{0,2}
//! a_{1,0} & a_{1,1} & a_{1,2}
\end{array}
\right] 
\f$\f$

//! The Matrix class provides the implementation of a general unsymmetric
//! matrix. The data for the matrix is stored in a 1d double array of size
//! numRows*numCols with the data for \f$a_{i,j}\f$ located at j*numRows + i
//! in the 1d array. This is similar to the ordering of a Fortran 2d array
//! and will permit calls to numerical Fortran libraries, e.g. BLAS, for
//! certain method calls at a future stage. At present no subclassing is
//! permitted (THIS MAY CHANGE), the reason for this is that the Matrix
//! objects are envisioned to be small scale matrices primarily used for
//! the passing of data between objects in the system. To allow subclassing
//! could reduce the efficiency of the program due to the manner in which 
//! virtual functions are implemented. 



\noindent {\bf Constructors}
\indent {\em Matrix();}
//! To construct a Matrix with numRows = \f$0\f$, and numCols = \f$0\f$. No memory
//! is allocated to store the data. 

\indent {\em  Matrix(int nrows, int ncols);}

\indent {\em  Matrix(double *data, int nrows, int ncols);}



\noindent {\bf Public Methods }
\indent {\em  inline int noRows() const;}
//! Returns the number of rows, numRows, of the Matrix. The method is
//! declared inline for the compiler to produce faster code which does not
//! require a method call.

\indent {\em  inline int noCols() const;}
//! Returns the number of columns, numCols, of the Matrix.




\noindent {\bf Overloaded Operator Functions}
\indent {\em  inline double \&operator()(int row, int col) const;}
//! Returns the data at location({\em row,col}) in the Matrix. Assumes
({\em row,col}) is a valid location in the Matrix, a segmentation
//! fault or erroneous results can occur if this is not the case.

\indent {\em  inline double \&operator()(int row, int col);}
//! Used to set the data at location({\em row,col}) in the Matrix. Assumes
({\em row,col}) is a valid location in the Matrix, a segmentation
//! fault or erroneous results can occur if this is not the case.

\indent {\em  Matrix operator()(const ID \&rows, const ID \&
//! cols) const;} 

\indent {\em  Matrix \&operator=(const Matrix \&M);}
//! Sets the current Matrix to be equal to the Matrix given by \p M. If
//! the Matrices are of different sizes, the current data is deallocated
//! and additional space allocated before the contents are copied. If not
//! enough space can be allocated for the new data, an error message is
//! printed and a Matrix of size \f$0\f$ x \f$0\f$ is returned. The method tests
//! for the type of \p M, to see whether the performance can be
//! improved by avoiding having to call \f$M\f$'s overloaded (i,j) operators,
//! if \f$M\f$ is of type genMatrix. This method must be implemented by each
//! subclass. 

\indent {\em  Matrix \&operator+=(double fact);}

\indent {\em Matrix \&operator-=(double fact);}

\indent {\em Matrix \&operator*=(double fact);}

\indent {\em Matrix \&operator/=(double fact); }

\indent {\em Matrix operator+(double fact) const;}

\indent {\em Matrix operator-(double fact) const;}


\indent {\em Matrix operator*(double fact) const;}

\indent {\em Matrix operator/(double fact) const;}

\indent {\em Vector operator*(const Vector \&V) const;}

\indent {\em Vector operator { }\f$ \hat{ }\f$(const Vector
\&V) const; } 
//! A method to return a new Vector, of size numCols, whose components are
//! equal to the product of the transpose of the current Matrix times the
//! Vector \p V. If the current Matrix and Vector \p V are not
//! compatible, i.e. V.Size() is not equal to numRows, an error message is
//! printed and a zero Vector of size equal to the number of columns in
//! the current Matrix is returned. The method tests for the type of the
//! current Matrix, to see whether the performance can be improved by
//! avoiding having to call the overloaded (i,j) operators, if the current
//! Matrix is of type genMatrix. 

\indent {\em Matrix operator+(const Matrix \&M) const;}
//! A method to return a new Matrix equal to the sum of the current Matrix
//! and the Matrix \p M. It does this by creating a new matrix passing
//! itself as an argument to the constructor. The addMatrix() method
//! is then invoked on this new Matrix with \f$M\f$ and \f$-1\f$ as the
//! arguments. The new Matrix is then returned. 

\indent {\em Matrix operator-(const Matrix \&M) const;}
//! A method to return a new Matrix equal to the the current Matrix minus
//! the Matrix \p M. It does this by creating a new matrix passing
//! itself as an argument to the constructor. The addMatrix() method
//! is then invoked on this new Matrix with \f$M\f$ and \f$-1\f$ as the
//! arguments. The new Matrix is then returned. 

\indent {\em Matrix operator*(const Matrix \&M) const;}
//! A method to return a new Matrix equal to the product of the current
//! Matrix and the Matrix \p M. It does this by first creating a new
//! Matrix of size numRows and M.numCols. The contents of this new Matrix
//! are then determined and the resulting Matrix is returned. If the two
//! matrices are of incompatible sizes, a warning message is printed and a
//! zeroed Matrix is returned. The method tests for the type of the
//! current Matrix, to see whether the performance can be improved by
//! avoiding having to call the overloaded (i,j) operators, if \p M 
//! is of type genMatrix.

\indent {\em Matrix operator{ }\f$ \hat{ }\f$(const Matrix \&M)
//! const;} 
//! A method to return a new Matrix equal to the product of the transpose
//! of the current Matrix and the Matrix \p M. It does this by first
//! creating a new Matrix of size numRows and M.numRows. The contents of
//! this new Matrix are then determined and the resulting Matrix is
//! returned. If the two matrices are of incompatible sizes, a warning
//! message is printed and a zeroed Matrix is returned. The method tests
//! for the type of the current Matrix, to see whether the performance can
//! be improved by avoiding having to call the overloaded (i,j) operators,
//! if \p M is of type genMatrix.

\indent {\em void Output(OPS_Stream \&s) const;}
//! To print the contents of the Matrix to the output stream \p s. The
//! method will print the contents one row at a time. 

\indent {\em void Input(istream \&s);}
//! To read the contents of the Matrix from the input stream \p s. The method expects the components one row at a time.

{\em friend OPS_Stream \&operator\f$<<\f$(OPS_Stream \&s, const Matrix \&M);}
//! A function to print out the contents of the Matrix \p M to the
//! output stream \p s. Does this by invoking Output() on the
//! Matrix \p M. 

{\em friend OPS_Stream \&operator\f$>>\f$(istream \&s, const Matrix \&M);}
//! A function to print out the contents of the Matrix \p M to the
//! output stream \p s. Does this by invoking Output() on the
//! Matrix \p M. 

