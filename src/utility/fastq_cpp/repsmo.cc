/* repsmo.f -- translated by f2c (version 20160102).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#ifdef __cplusplus
extern "C" {
#endif
#include "fastq_cpp.h"

/*    Copyright(C) 1999-2020 National Technology & Engineering Solutions */
/*    of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with */
/*    NTESS, the U.S. Government retains certain rights in this software. */

/*    See packages/seacas/LICENSE for details */
/* Subroutine */ int repsmo_(integer *mxnd, real *xn, real *yn, integer *lxn, 
	integer *nnn, integer *nnnold, integer *nit, real *eps, real *ro, 
	integer *m1)
{
    /* System generated locals */
    integer i__1, i__2;
    real r__1, r__2;

    /* Local variables */
    static integer nb, it, nt;
    static logical big;
    static real eps2;
    static integer node;
    static real delx, dely, xphi, yphi, xpsi, ypsi;
    static integer nrow;
    static real xsum, beta2, ysum, gamma, alpha, weight;

/* *********************************************************************** */
/*  SUBROUTINE REPSMO = SMOOTHS A MESH GENERATED BY RMESH BY THE */
/*                      EQUIPOTENTIAL, OR WEIGHTED LAPLACIAN METHOD. */
/*                      GAUSS-SEIDEL TYPE RELAXATION IS USED. */
/*     REFERENCE--MESH GENERATION-A SURVEY, BY BUELL AND BUSH, F.M.C. */
/* *********************************************************************** */
/*     NIT - MAX NUMBER OF ITERATIONS */
/*     EPS - CONVERGENCE CRITERION FOR NODE MOVEMENTS */
/*     RO  - RELAXATION FACTOR  (USUALLY 1.0 OR LARGER) */
/*     M1  - SAME AS M1 GIVEN TO RMESH.  THE MESH MUST BE LOGICALLY */
/*           EXACTLY AS PRODUCED BY RMESH. */
/* *********************************************************************** */
    /* Parameter adjustments */
    lxn -= 5;
    --yn;
    --xn;

    /* Function Body */
/* Computing 2nd power */
    r__1 = *eps * *ro;
    eps2 = r__1 * r__1;
    nrow = *m1 + 1;
/*  ITERATION LOOP */
    i__1 = *nit;
    for (it = 1; it <= i__1; ++it) {
	big = FALSE_;
/*  NODE LOOP */
	i__2 = *nnn;
	for (node = *nnnold + 1; node <= i__2; ++node) {
/*  SKIP BOUNDARY NODES */
	    if (lxn[(node << 2) + 2] > 0) {
		nt = node + nrow;
		nb = node - nrow;
/*  COMPUTE WEIGHTS */
		xphi = (xn[nt] - xn[nb]) * (float).5;
		yphi = (yn[nt] - yn[nb]) * (float).5;
		xpsi = (xn[node + 1] - xn[node - 1]) * (float).5;
		ypsi = (yn[node + 1] - yn[node - 1]) * (float).5;
/* Computing 2nd power */
		r__1 = xpsi;
/* Computing 2nd power */
		r__2 = ypsi;
		alpha = r__1 * r__1 + r__2 * r__2;
/* Computing 2nd power */
		r__1 = xphi;
/* Computing 2nd power */
		r__2 = yphi;
		gamma = r__1 * r__1 + r__2 * r__2;
		beta2 = (xphi * xpsi + yphi * ypsi) * (float).5;
		weight = (alpha + gamma) * (float)2.;
/*  COMPUTE WEIGHTED SUM OF COORDINATES */
		xsum = alpha * (xn[nt] + xn[nb]) + gamma * (xn[node - 1] + xn[
			node + 1]) + beta2 * (xn[nt - 1] + xn[nb + 1] - xn[nt 
			+ 1] - xn[nb - 1]);
		ysum = alpha * (yn[nt] + yn[nb]) + gamma * (yn[node - 1] + yn[
			node + 1]) + beta2 * (yn[nt - 1] + yn[nb + 1] - yn[nt 
			+ 1] - yn[nb - 1]);
/*  MOVE THE NODE AS INDICATED */
		delx = (xsum / weight - xn[node]) * *ro;
		dely = (ysum / weight - yn[node]) * *ro;
		xn[node] += delx;
		yn[node] += dely;
/* Computing 2nd power */
		r__1 = delx;
/* Computing 2nd power */
		r__2 = dely;
		if (r__1 * r__1 + r__2 * r__2 > eps2) {
		    big = TRUE_;
		}
	    }
/* L100: */
	}
	if (! big) {
	    return 0;
	}
/* L110: */
    }
    return 0;
} /* repsmo_ */

#ifdef __cplusplus
	}
#endif
